#!/bin/bash

# Rofi VM Manager (script modi, 2-step menu: VM -> actions)

DEBUG_LOG="/tmp/rofi-vm-debug.log"
STATE_FILE="${XDG_RUNTIME_DIR:-/tmp}/rofi-vm.state"
CACHE_FILE="${XDG_RUNTIME_DIR:-/tmp}/rofi-vm.cache"
CACHE_TIMEOUT=30  # Cache VM info for 30 seconds (longer cache)
FAST_MODE=true    # Enable fast mode optimizations

log_debug() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $*" >> "$DEBUG_LOG"
}

# Icons (Nerd Fonts)
start_icon='󰐊'
connect_icon='󰍹'
shutdown_icon='󰐥'
reboot_icon='󰜉'
suspend_icon='󰤄'
resume_icon='󰤁'
force_off_icon='󰈸'

running_color='#a6e3a1'
stopped_color='#f38ba8'

# --- libvirt helpers --------------------------------------------------------

# Cache management
is_cache_valid() {
    if [[ ! -f "$CACHE_FILE" ]]; then
        return 1
    fi
    
    local cache_age
    cache_age=$(($(date +%s) - $(stat -c %Y "$CACHE_FILE" 2>/dev/null || echo 0)))
    [[ $cache_age -lt $CACHE_TIMEOUT ]]
}

get_vms_cached() {
    if is_cache_valid; then
        log_debug "Using cached VM data"
        grep "^VM:" "$CACHE_FILE" | cut -d: -f2
        return
    fi
    
    log_debug "Refreshing VM cache (background mode: $FAST_MODE)"
    
    if [[ "$FAST_MODE" == "true" ]]; then
        # Fast mode: Start background refresh and return cached data if available
        refresh_cache_background &
        
        # If we have any cached data (even expired), use it for instant response
        if [[ -f "$CACHE_FILE" ]]; then
            log_debug "Using stale cache for fast response"
            grep "^VM:" "$CACHE_FILE" | cut -d: -f2
            return
        fi
    fi
    
    # Fallback: synchronous refresh (only if no cache exists at all)
    refresh_cache_sync
    grep "^VM:" "$CACHE_FILE" 2>/dev/null | cut -d: -f2
}

refresh_cache_background() {
    # Background refresh - don't block rofi
    (
        refresh_cache_sync
        log_debug "Background cache refresh completed"
    ) &
}

refresh_cache_sync() {
    local temp_cache="${CACHE_FILE}.tmp"
    
    # Try different connection URIs - use timeout to prevent hanging
    local conn_uri=""
    local vms=""
    
    # Use timeout to prevent slow libvirt calls from blocking
    if timeout 2s virsh -c qemu:///system list --all --name 2>/dev/null | grep -v '^$' | grep -q .; then
        conn_uri="qemu:///system"
        vms=$(timeout 3s virsh -c qemu:///system list --all --name 2>/dev/null | grep -v '^$' | sort)
    elif timeout 2s virsh -c qemu:///session list --all --name 2>/dev/null | grep -v '^$' | grep -q .; then
        conn_uri="qemu:///session"
        vms=$(timeout 3s virsh -c qemu:///session list --all --name 2>/dev/null | grep -v '^$' | sort)
    elif timeout 2s virsh list --all --name 2>/dev/null | grep -v '^$' | grep -q .; then
        conn_uri=""
        vms=$(timeout 3s virsh list --all --name 2>/dev/null | grep -v '^$' | sort)
    fi
    
    # Build cache atomically
    {
        echo "CONN_URI:$conn_uri"
        while IFS= read -r vm; do
            if [[ -n "$vm" ]]; then
                local status
                if [[ -n "$conn_uri" ]]; then
                    status=$(timeout 2s virsh -c "$conn_uri" dominfo "$vm" 2>/dev/null | awk '/State:/ {print $2}')
                else
                    status=$(timeout 2s virsh dominfo "$vm" 2>/dev/null | awk '/State:/ {print $2}')
                fi
                echo "VM:$vm:${status:-unknown}"
            fi
        done <<< "$vms"
    } > "$temp_cache" && mv "$temp_cache" "$CACHE_FILE"
}

get_vms() {
    get_vms_cached
}

get_vm_status() {
    local vm_name="$1"
    
    # Try to get from cache first
    if is_cache_valid; then
        local cached_status
        cached_status=$(grep "^VM:$vm_name:" "$CACHE_FILE" 2>/dev/null | cut -d: -f3)
        if [[ -n "$cached_status" ]]; then
            echo "$cached_status"
            return
        fi
    fi
    
    # Fallback to live query
    local conn_uri
    conn_uri=$(get_connection_uri)
    
    local status=""
    if [[ -n "$conn_uri" ]]; then
        status=$(virsh -c "$conn_uri" dominfo "$vm_name" 2>/dev/null | awk '/State:/ {print $2}')
    else
        status=$(virsh dominfo "$vm_name" 2>/dev/null | awk '/State:/ {print $2}')
    fi
    
    echo "$status"
}

get_connection_uri() {
    # Try to get from cache first
    if is_cache_valid; then
        local cached_uri
        cached_uri=$(grep "^CONN_URI:" "$CACHE_FILE" 2>/dev/null | cut -d: -f2-)
        if [[ -n "$cached_uri" ]]; then
            echo "$cached_uri"
            return
        fi
    fi
    
    # Fallback to live query
    if virsh -c qemu:///system list --all --name 2>/dev/null | grep -v '^$' | grep -q .; then
        echo "qemu:///system"
    elif virsh -c qemu:///session list --all --name 2>/dev/null | grep -v '^$' | grep -q .; then
        echo "qemu:///session"
    else
        echo ""
    fi
}

# --- rofi output helpers ----------------------------------------------------

print_vm_list() {
    # metadata for rofi (script mode)
    printf '\0prompt\x1f%s\n' "VMs"
    printf '\0mesg\x1f%s\n' "Select a VM to manage"
    printf '\0markup-rows\x1ftrue\n'
    printf '\0no-custom\x1ftrue\n'

    local vms
    vms=$(get_vms)
    if [ -z "$vms" ]; then
        # Show a message if no VMs found
        printf "<span color='%s'>No VMs found</span>\n" "$stopped_color"
        return
    fi

    # Fast display using cached data
    if is_cache_valid; then
        # Use cached status data for instant display
        while IFS= read -r vm; do
            [ -z "$vm" ] && continue
            local cached_status
            cached_status=$(grep "^VM:$vm:" "$CACHE_FILE" 2>/dev/null | cut -d: -f3)
            
            if [[ "$cached_status" == "running" ]]; then
                printf "<span color='%s'>●</span> %s (running)\n" "$running_color" "$vm"
            else
                printf "<span color='%s'>○</span> %s (stopped)\n" "$stopped_color" "$vm"
            fi
        done <<< "$vms"
    else
        # Fallback: show VMs without status for instant display, status will update on background refresh
        while IFS= read -r vm; do
            [ -z "$vm" ] && continue
            printf "<span color='%s'>○</span> %s\n" "$stopped_color" "$vm"
        done <<< "$vms"
    fi
}

print_actions_for_vm() {
    local vm_name="$1"
    local status
    status=$(get_vm_status "$vm_name")

    printf '\0prompt\x1f%s\n' "VM: $vm_name"
    printf '\0mesg\x1f%s\n' "Status: $status"
    printf '\0no-custom\x1ftrue\n'
    printf '\0markup-rows\x1ffalse\n'

    if [[ "$status" == "running" ]]; then
        printf "%s Connect\n" "$connect_icon"
        printf "%s Shutdown\n" "$shutdown_icon"
        printf "%s Reboot\n" "$reboot_icon"
        printf "%s Suspend\n" "$suspend_icon"
        printf "%s Force Off\n" "$force_off_icon"
    else
        printf "%s Start\n" "$start_icon"
        if [[ "$status" == "paused" ]]; then
            printf "%s Resume\n" "$resume_icon"
        fi
    fi
}

# --- action execution -------------------------------------------------------

execute_action() {
    local vm_name="$1"
    local action="$2"
    local conn_uri
    conn_uri=$(get_connection_uri)

    local virsh_cmd=(virsh)
    [ -n "$conn_uri" ] && virsh_cmd=(virsh -c "$conn_uri")

    log_debug "execute_action: vm='$vm_name', action='$action', conn_uri='$conn_uri'"

    case "$action" in
        *"Connect"*)
            log_debug "Connect requested for '$vm_name' (conn_uri='$conn_uri')"
            if command -v virt-viewer &>/dev/null; then
                if [ -n "$conn_uri" ]; then
                    nohup virt-viewer --connect "$conn_uri" "$vm_name" \
                        >/dev/null 2>&1 </dev/null &
                else
                    nohup virt-viewer "$vm_name" \
                        >/dev/null 2>&1 </dev/null &
                fi
                log_debug "Started virt-viewer for '$vm_name'"
            elif command -v virt-manager &>/dev/null; then
                if [ -n "$conn_uri" ]; then
                    nohup virt-manager --connect "$conn_uri" --show-domain-console "$vm_name" \
                        >/dev/null 2>&1 </dev/null &
                else
                    nohup virt-manager --connect qemu:///system --show-domain-console "$vm_name" \
                        >/dev/null 2>&1 </dev/null &
                fi
                log_debug "Started virt-manager for '$vm_name'"
            else
                log_debug "Neither virt-viewer nor virt-manager found"
                notify-send "VM Manager" "virt-viewer or virt-manager not found"
            fi
            ;;

         *"Start"*)
             if "${virsh_cmd[@]}" start "$vm_name" &>>"$DEBUG_LOG"; then
                 notify-send "VM Manager" "Started $vm_name"
                 clear_cache  # Clear cache so status updates immediately
             else
                 notify-send "VM Manager" "Failed to start $vm_name"
             fi
             ;;
         *"Shutdown"*)
             if "${virsh_cmd[@]}" shutdown "$vm_name" &>>"$DEBUG_LOG"; then
                 notify-send "VM Manager" "Shutting down $vm_name"
                 clear_cache  # Clear cache so status updates immediately
             else
                 notify-send "VM Manager" "Failed to shutdown $vm_name"
             fi
             ;;
         *"Reboot"*)
             if "${virsh_cmd[@]}" reboot "$vm_name" &>>"$DEBUG_LOG"; then
                 notify-send "VM Manager" "Rebooting $vm_name"
                 clear_cache  # Clear cache so status updates immediately
             else
                 notify-send "VM Manager" "Failed to reboot $vm_name"
             fi
             ;;
         *"Suspend"*)
             if "${virsh_cmd[@]}" suspend "$vm_name" &>>"$DEBUG_LOG"; then
                 notify-send "VM Manager" "Suspended $vm_name"
                 clear_cache  # Clear cache so status updates immediately
             else
                 notify-send "VM Manager" "Failed to suspend $vm_name"
             fi
             ;;
         *"Resume"*)
             if "${virsh_cmd[@]}" resume "$vm_name" &>>"$DEBUG_LOG"; then
                 notify-send "VM Manager" "Resumed $vm_name"
                 clear_cache  # Clear cache so status updates immediately
             else
                 notify-send "VM Manager" "Failed to resume $vm_name"
             fi
             ;;
         *"Force Off"*)
             if "${virsh_cmd[@]}" destroy "$vm_name" &>>"$DEBUG_LOG"; then
                 notify-send "VM Manager" "Force stopped $vm_name"
                 clear_cache  # Clear cache so status updates immediately
             else
                 notify-send "VM Manager" "Failed to force stop $vm_name"
             fi
             ;;
    esac
}

# --- state management -------------------------------------------------------

load_state() {
    if [[ -f "$STATE_FILE" ]]; then
        # shellcheck disable=SC1090
        . "$STATE_FILE"
    else
        stage="list"
        vm_name=""
    fi
}

save_state_actions() {
    local vm="$1"
    cat >"$STATE_FILE" <<EOF
stage="actions"
vm_name="$(printf '%s\n' "$vm" | sed 's/"/\\"/g')"
EOF
}

clear_state() {
    rm -f "$STATE_FILE"
}

clear_cache() {
    rm -f "$CACHE_FILE"
}

# --- selection parsing ------------------------------------------------------

extract_vm_name_from_line() {
    # strip markup tags, bullets, and trailing " (status)"
    sed -E 's/<[^>]*>//g' \
    | sed -E 's/^[●○]\s*//' \
    | sed -E 's/\s*\(.*\)$//' \
    | xargs
}

# --- main -------------------------------------------------------------------

log_debug ""
log_debug "=== rofi-vm start ==="
log_debug "ROFI_RETV='${ROFI_RETV:-unset}', args='$*'"

load_state
log_debug "Loaded state: stage='$stage', vm_name='$vm_name'"

if [[ "${ROFI_RETV:-0}" == "0" ]]; then
    # Initial call: reset to VM list every time rofi opens
    log_debug "ROFI_RETV=0 -> print VM list (fast mode)"
    clear_state
    
    # Pre-warm cache in background if needed
    if ! is_cache_valid && [[ "$FAST_MODE" == "true" ]]; then
        log_debug "Starting background cache refresh for next time"
        refresh_cache_background
    fi
    
    print_vm_list
    exit 0
fi

# ROFI_RETV != 0: user selected an entry
selection="$1"
log_debug "Selection raw: '$selection'"

if [[ "$stage" == "list" ]]; then
    # First selection: user chose a VM; go to actions menu
    vm_selected=$(echo "$selection" | extract_vm_name_from_line)
    log_debug "VM selected: '$vm_selected'"
    
    # Save state and show actions for this VM
    save_state_actions "$vm_selected"
    print_actions_for_vm "$vm_selected"
    exit 0
elif [[ "$stage" == "actions" ]]; then
    # Second selection: user chose an action; execute it
    log_debug "Action selected: '$selection' for VM: '$vm_name'"
    clear_state
    execute_action "$vm_name" "$selection"
    exit 0
fi
